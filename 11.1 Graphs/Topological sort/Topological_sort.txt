
Suppose we have a graph, where the outgoing nodes are given as "->" and the inside graph are given as "<-"

The first vertex in topological sorting is always a vertex with degree 0 (With no incoming edges).

5->0,2
4->0,1
2->3
3->1


The topological sorting  for the above graph will be 5,4,2,3,1,0

******************************************* Normal DFS *********************************************************************

//In the Normal DFS, we print the vertex given, mark it as visited and then call the function recursively on the adjacent vertices

******************************************* Topological sort *****************************************************************

1. Use a temporary stack
2. Don't print the vertex
3. Call the topological sort function recursively for all its adjacent vertices and push it to stack
4. Print the content of the stack


Vertex is pushed to the stack only when all of its adjacent vertices (and their adjacent vertices) are in stack

**************************************************************************************************************************
                                                  DFS


The process of the psuedo code for the DFS part of the topological sort function is

1. You take a number of the vertices,
2. Mark the current vertex as visited
3. Perform the DFS from the current vertex
4. Push the current vertex in the stack

************************************************************************************************************************

                                            Topological sort

1. Loop trough the number of Vertices and check if they are in the Visited Array
2. If they are not in the Visited Array call the DFS function on them
3. Now while the stack is not empty print the top element and then pop the stack

************************************************************************************************************************

What does DFS do, when to use it?

It's a question of what you're optimizing for.

If you're optimizing to find the shortest possible route (by number of hops), then you need to do a breadth-first search.
 Why? Because if you're always expanding the shortest routes you have, then as soon as you find any route you know that
  it must be the shortest, because if any shorter route existed you would have already found it.

Essentially what you're doing it asking "Can I go from start to end in 0 hops? No. Can I do it in 1 hop? No.
Can I do it in 2 hops? No. Can I do it in 3 hops? YES, and so now I'm done".

But other times, we don't care if we find the shortest route--we just want to know if a route exists at all.
For example, if you're playing some sort of game, then as soon as you find a guaranteed winning sequence of moves,
 you know you're going to win. It doesn't matter if there were a shorter sequence of moves or not;
 we just wanted a winning play pattern and we found one.

In some cases, though, if we need to flood-fill all nodes, it doesn't really matter which you use; you end
up visiting every node exactly once either way. In that case you can use whichever is easier and faster; and often the
DFS can be expressed recursively in a much cleaner fashion.

I would also point out that there's a third option--Djikstra's algorithm, where you use a heap and some kind of
heuristic to order your search (rather than a queue for BFS or a stack for DFS). With a heap you are paying for the
overhead of push/pop operations (which are O(log N) rather than O(1) for a stack/queue) but it lets you prioritize your
search by some other metric. Sometimes that's useful.

So to summarize:

1. When in doubt, use BFS. It performs the same as DFS in the worst case and is significantly faster at finding
   the shortest route.

2.  When you only need to find one route and don't care how long it is, use DFS particularly if you can express it
    recursively.

3. When you need to find the "best" route, and "best" isn't just "shortest", then consider using Djikstra's and a heap.



************************************************************************************************************************

    BFS:  Tries to explore all the neighbors it can reach from the current node. It will use a queue data structure.
    DFS:  Tries to reach the farthest node from the current node and come back (backtrack) to the current node to
           explore its other neighbors. This will use a stack data structure.


************************************************************************************************************************



    We will prefer to use BFS when we know that our solution might lie closer to the starting point or if the graph
     has greater depths.

    We will prefer to use DFS when we know our solution might lie farthest from the starting point or when the graph
    has a greater width.

    If we have multiple starting points and the problem requires us to start traversing all those starting points
    parallelly then we can think of BFS as we can push all those starting points in the queue and start exploring
    them first.

    Itâ€™s generally a good idea to use BFS if we need to find the shortest distance from a node in the unweighted graph.

    We will be using DFS mostly in path-finding algorithms to find paths between nodes.
